<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/mywebsite/libs/highlight/styles/github.min.css"> <link rel=stylesheet  href="/mywebsite/css/jtd.css"> <link rel=icon  href="/mywebsite/assets/favicon.ico"> <style> /* #148 wrap long header */ .franklin-content a.header-anchor, .franklin-toc li a { word-wrap: break-word; white-space: normal; } </style> <title>如何用 100 行代码得到一个 Fillippov 系统的求解器</title> <div class=page-wrap > <div class=side-bar > <div class=header > <a href="/mywebsite/" class=title > 晓明的主页 </a> </div> <label for=show-menu  class=show-menu >MENU</label> <input type=checkbox  id=show-menu  role=button > <div class=menu  id=side-menu > <ul class=menu-list > <li class="menu-list-item "><a href="/mywebsite/" class="menu-list-link ">Home</a> <li class="menu-list-item "><a href="/mywebsite/menu1/" class="menu-list-link ">Code blocks</a> <li class="menu-list-item "><a href="/mywebsite/blog/" class="menu-list-link ">博客</a> <li class="menu-list-item "><a href="/mywebsite/menu2/" class="menu-list-link ">About me</a> <!-- <ul class="menu-list-child-list "> <li class="menu-list-item "><a href="#" class=menu-list-link >Submenu</a> --> </ul> </ul> </div> <div class=footer > Built by <a href="https://github.com/tlienart/Franklin.jl" target=_blank >Franklin</a> </div> </div> <div class=main-content-wrap > <div class=main-content > <div class=main-header > <a id=github  href="https://github.com/Xiaomingzzhang/mywebsite">Source on Github</a> </div> <div class=franklin-content > <h1 id="如何用_100_行代码得到一个_fillippov_系统的求解器"><a href="#如何用_100_行代码得到一个_fillippov_系统的求解器" class=header-anchor >如何用 100 行代码得到一个 Fillippov 系统的求解器</a></h1> <p>Fillippov 是一类分段光滑的 ODE &#40;Ordinary Differential Equation&#41; 系统, 该系统在相空间中存在着一个超曲面, 这个超曲面将矢量场分成两个部分, 这两个部分的矢量场是不同的. Fillippov 系统在一定条件下允许系统的轨线穿过这个超曲面, 甚至允许轨线在这个超曲面上滑移. 这样高度复杂的非光滑给数值计算带来了挑战. 然而凭借 Julia 中的 <a href="https://github.com/SciML/DifferentialEquations.jl">DifferentialEquation.jl</a> 强大的事件处理能力, 我们将仅用 100 行代码实现这类 Fillippov 系统的求解, 并且该求解器是一般的, 适用于任意维度的 Fillippov 系统.</p> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> StaticArrays, OrdinaryDiffEq, Plots, LinearAlgebra

<span class=hljs-keyword >struct</span> ODESol
    solution <span class=hljs-comment ># ODE solution solved by OrdinaryDiffEq.jl</span>
    state::<span class=hljs-built_in >Symbol</span> <span class=hljs-comment ># only two symbols are used: :regularmode and :slidemode</span>
<span class=hljs-keyword >end</span>

<span class=hljs-keyword >function</span> fillippov_solve(f1, f2, h, ∇h, v0, p0, t0, tend)
    <span class=hljs-comment ># it is assumed that f1 is at h(x)&lt;0 and f2 is at h(x)&gt;0</span>
    <span class=hljs-comment ># f1, f2, h, ∇h are all type of f(u, p, t), the output is a vector</span>
    <span class=hljs-comment ># initial condition: v0 </span>
    <span class=hljs-comment ># time interval: t0,tend</span>
    <span class=hljs-comment ># parameter p0</span>
    <span class=hljs-comment ># </span>
    <span class=hljs-comment ># first define the vector field on the switch surface</span>
    <span class=hljs-keyword >function</span> sv(x, p, t)
        α = dot(∇h(x, p, t), f1(x, p, t)) / dot(∇h(x, p, t), f1(x, p, t) - f2(x, p, t))
        (<span class=hljs-number >1</span> - α) * f1(x, p, t) + α * f2(x, p, t)
    <span class=hljs-keyword >end</span>

    <span class=hljs-comment ># the hyper surface </span>
    <span class=hljs-keyword >function</span> newh(x, t, integrator)
        h(x, integrator.p, t)
    <span class=hljs-keyword >end</span>
    <span class=hljs-comment ># stop the integrator</span>
    <span class=hljs-keyword >function</span> stop(integrator)
        <span class=hljs-keyword >if</span> (integrator.t-integrator.sol.t[<span class=hljs-number >1</span>])&lt; <span class=hljs-number >1e-2</span> <span class=hljs-comment ># to avoid the </span>
            <span class=hljs-literal >nothing</span>
        <span class=hljs-keyword >else</span>
            terminate!(integrator)
        <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >end</span>

    <span class=hljs-comment ># exit the sliding mode when slide_exit=0</span>
    <span class=hljs-keyword >function</span> slide_exit(x, t, integrator)
        dot(∇h(x, integrator.p, t), f2(x, integrator.p, t)) * dot(∇h(x, integrator.p, t), f1(x, integrator.p, t))
    <span class=hljs-keyword >end</span>

    <span class=hljs-comment ># main data consist of different solutions at h&gt;0, h&lt;0 and h=0</span>
    sols = <span class=hljs-built_in >Vector</span>{ODESol}(<span class=hljs-literal >undef</span>, <span class=hljs-number >1</span>)

    <span class=hljs-keyword >if</span> abs(h(v0, p0, t0)) &lt; <span class=hljs-number >1e-10</span> <span class=hljs-comment ># if this happen, we assume that the initial condition is on h=0</span>
        prob = ODEProblem(sv, v0, (t0, tend), p0)
        cb = ContinuousCallback(slide_exit, stop)
        firstsol = ODESol(solve(prob, Vern6(), callback=cb), :slidemode)
        sols[<span class=hljs-number >1</span>] = firstsol
    <span class=hljs-keyword >elseif</span> h(v0, p0, t0) &gt; <span class=hljs-number >0</span>
        prob = ODEProblem(f2, v0, (t0, tend), p0)
        cb = ContinuousCallback(newh, stop)
        firstsol = ODESol(solve(prob, Vern6(), callback=cb), :regularmode)
        sols[<span class=hljs-number >1</span>] = firstsol
    <span class=hljs-keyword >else</span>
        prob = ODEProblem(f1, v0, (t0, tend), p0)
        cb = ContinuousCallback(newh, stop)
        firstsol = ODESol(solve(prob, Vern6(), callback=cb), :regularmode)
        sols[<span class=hljs-number >1</span>] = firstsol
    <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >while</span> sols[<span class=hljs-keyword >end</span>].solution.t[<span class=hljs-keyword >end</span>] != tend <span class=hljs-comment ># if the last of sols&#x27;s time ≠ tend</span>
        v1 = sols[<span class=hljs-keyword >end</span>].solution.u[<span class=hljs-keyword >end</span>]
        t1 = sols[<span class=hljs-keyword >end</span>].solution.t[<span class=hljs-keyword >end</span>]
        <span class=hljs-keyword >if</span> sols[<span class=hljs-keyword >end</span>].state == :slidemode <span class=hljs-comment ># if the last solution is in slidemode, we have to determine which vector field it enter</span>
            <span class=hljs-keyword >if</span> abs(dot(∇h(v1, p0, t1), f2(v1, p0, t1))) &lt; <span class=hljs-number >1e-8</span> &amp;&amp; dot(∇h(v1, p0, t1), f1(v1, p0, t1)) &gt; <span class=hljs-number >1e-5</span>
                prob = ODEProblem(f2, v1, (t1, tend), p0)
                cb = ContinuousCallback(newh, stop, repeat_nudge=<span class=hljs-number >0.2</span>)
                firstsol = ODESol(solve(prob, Vern6(), callback=cb), :regularmode)
                append!(sols, [firstsol])
            <span class=hljs-keyword >elseif</span> abs(dot(∇h(v1, p0, t1), f1(v1, p0, t1))) &lt; <span class=hljs-number >1e-8</span> &amp;&amp; dot(∇h(v1, p0, t1), f2(v1, p0, t1)) &lt; -<span class=hljs-number >1e-5</span>
                prob = ODEProblem(f1, v1, (t1, tend), p0)
                cb = ContinuousCallback(newh, stop, repeat_nudge=<span class=hljs-number >0.2</span>)
                firstsol = ODESol(solve(prob, Vern6(), callback=cb), :regularmode)
                append!(sols, [firstsol])
            <span class=hljs-keyword >else</span>
                <span class=hljs-keyword >break</span>
                print(<span class=hljs-string >&quot;The solution is not defined on state <span class=hljs-variable >$v1</span> and time <span class=hljs-variable >$t1</span>&quot;</span>)
            <span class=hljs-keyword >end</span>
        <span class=hljs-keyword >else</span>
            <span class=hljs-keyword >if</span> dot(∇h(v1, p0, t1), f1(v1, p0, t1)) * dot(∇h(v1, p0, t1), f2(v1, p0, t1)) &gt; <span class=hljs-number >0</span> <span class=hljs-comment ># crossing h=0</span>
                <span class=hljs-keyword >if</span> dot(∇h(v1, p0, t1), f1(v1, p0, t1)) &gt; <span class=hljs-number >0</span>
                    prob = ODEProblem(f2, v1, (t1, tend), p0)
                    cb = ContinuousCallback(newh, stop, repeat_nudge=<span class=hljs-number >0.2</span>)
                    firstsol = ODESol(solve(prob, Vern6(), callback=cb), :regularmode)
                    append!(sols, [firstsol])
                <span class=hljs-keyword >else</span>
                    prob = ODEProblem(f1, v1, (t1, tend), p0)
                    cb = ContinuousCallback(newh, stop, repeat_nudge=<span class=hljs-number >0.2</span>)
                    firstsol = ODESol(solve(prob, Vern6(), callback=cb), :regularmode)
                    append!(sols, [firstsol])
                <span class=hljs-keyword >end</span>
            <span class=hljs-keyword >else</span> <span class=hljs-comment ># entering h=0</span>
                prob = ODEProblem(sv, v1, (t1, tend), p0)
                cb = ContinuousCallback(slide_exit, stop)
                firstsol = ODESol(solve(prob, Vern6(), callback=cb), :slidemode)
                append!(sols, [firstsol])
            <span class=hljs-keyword >end</span>
        <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >end</span>
    sols
<span class=hljs-keyword >end</span></code></pre> <!-- <div class=page-foot > Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> --> <div class=footer > Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and <a href="https://julialang.org">Julia</a>. </div></div> </div> </div> </div> <!-- end of class page-wrap--> <script src="/mywebsite/libs/highlight/highlight.min.js"></script> <script>hljs.highlightAll();hljs.configure({tabReplace: ' '});</script>